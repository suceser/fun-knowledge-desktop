# 趣知桌面版 - 日志监控

<div align="center">
  <h1>📊 趣知桌面版日志监控</h1>
  <p>完整的日志系统与应用监控方案</p>
</div>

---

## 📖 目录

1. [日志系统](#1-日志系统)
2. [性能监控](#2-性能监控)
3. [错误监控](#3-错误监控)
4. [数据分析](#4-数据分析)
5. [告警机制](#5-告警机制)
6. [可观测性](#6-可观测性)

---

## 1. 日志系统

### 1.1 日志级别

#### 日志级别定义

| 级别 | 用途 | 示例 |
|------|------|------|
| **error** | 错误信息，需要立即关注 | API调用失败、数据库错误 |
| **warn** | 警告信息，可能影响功能 | 配置缺失、性能降级 |
| **info** | 重要信息，关键操作记录 | 用户登录、数据导入 |
| **debug** | 调试信息，开发环境使用 | 函数调用、变量值 |
| **verbose** | 详细信息，完整流程记录 | 详细的请求响应 |

### 1.2 日志配置

#### electron-log配置

```typescript
// src/main/services/LoggerService.ts
import log from 'electron-log';
import { app } from 'electron';
import path from 'path';

export class LoggerService {
  private static instance: LoggerService;

  private constructor() {
    this.setupLogger();
  }

  public static getInstance(): LoggerService {
    if (!LoggerService.instance) {
      LoggerService.instance = new LoggerService();
    }
    return LoggerService.instance;
  }

  private setupLogger() {
    // 日志文件路径
    const logPath = path.join(app.getPath('userData'), 'logs');
    
    // 主进程日志配置
    log.transports.file.level = 'info';
    log.transports.file.maxSize = 10 * 1024 * 1024; // 10MB
    log.transports.file.format = '{y}-{m}-{d} {h}:{i}:{s}.{ms} [{level}] {text}';
    log.transports.file.resolvePath = (variables) => {
      return path.join(logPath, `main-${variables.fileName}`);
    };

    // 控制台输出配置
    log.transports.console.level = process.env.NODE_ENV === 'development' ? 'debug' : 'warn';
    log.transports.console.format = '{h}:{i}:{s} [{level}] {text}';

    // 日志轮转
    log.transports.file.archiveLog = (oldLogFile) => {
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const archivePath = path.join(logPath, 'archive', `${timestamp}.log`);
      
      require('fs').renameSync(oldLogFile.path, archivePath);
    };

    // 捕获未处理的异常
    this.setupErrorHandlers();
  }

  private setupErrorHandlers() {
    // 未捕获的异常
    process.on('uncaughtException', (error) => {
      log.error('Uncaught Exception:', error);
      // 不退出进程，记录错误继续运行
    });

    // 未处理的Promise拒绝
    process.on('unhandledRejection', (reason, promise) => {
      log.error('Unhandled Rejection at:', promise, 'reason:', reason);
    });
  }

  // 日志方法封装
  public error(message: string, ...args: any[]) {
    log.error(this.formatMessage(message), ...args);
  }

  public warn(message: string, ...args: any[]) {
    log.warn(this.formatMessage(message), ...args);
  }

  public info(message: string, ...args: any[]) {
    log.info(this.formatMessage(message), ...args);
  }

  public debug(message: string, ...args: any[]) {
    log.debug(this.formatMessage(message), ...args);
  }

  public verbose(message: string, ...args: any[]) {
    log.verbose(this.formatMessage(message), ...args);
  }

  private formatMessage(message: string): string {
    const stack = new Error().stack;
    const caller = stack?.split('\n')[3]?.trim() || '';
    return `[${caller}] ${message}`;
  }

  // 获取日志文件路径
  public getLogPath(): string {
    return log.transports.file.getFile().path;
  }

  // 清理旧日志
  public cleanOldLogs(daysToKeep: number = 7) {
    const logPath = path.join(app.getPath('userData'), 'logs');
    const fs = require('fs');
    const files = fs.readdirSync(logPath);
    
    const cutoffDate = Date.now() - daysToKeep * 24 * 60 * 60 * 1000;
    
    files.forEach((file: string) => {
      const filePath = path.join(logPath, file);
      const stats = fs.statSync(filePath);
      
      if (stats.mtime.getTime() < cutoffDate) {
        fs.unlinkSync(filePath);
        log.info(`Deleted old log file: ${file}`);
      }
    });
  }
}
```

#### 渲染进程日志

```typescript
// src/renderer/services/RendererLogger.ts
export class RendererLogger {
  private static sendToMain(level: string, message: string, ...args: any[]) {
    // 通过IPC发送日志到主进程
    window.electronAPI?.log?.send(level, message, ...args);
    
    // 本地也输出到控制台
    if (process.env.NODE_ENV === 'development') {
      console[level as 'log' | 'error' | 'warn' | 'info'](message, ...args);
    }
  }

  public static error(message: string, ...args: any[]) {
    this.sendToMain('error', message, ...args);
  }

  public static warn(message: string, ...args: any[]) {
    this.sendToMain('warn', message, ...args);
  }

  public static info(message: string, ...args: any[]) {
    this.sendToMain('info', message, ...args);
  }

  public static debug(message: string, ...args: any[]) {
    this.sendToMain('debug', message, ...args);
  }
}
```

### 1.3 结构化日志

#### 日志格式

```typescript
interface LogEntry {
  timestamp: string;
  level: 'error' | 'warn' | 'info' | 'debug';
  message: string;
  context?: {
    userId?: string;
    sessionId?: string;
    action?: string;
    module?: string;
  };
  metadata?: Record<string, any>;
  error?: {
    name: string;
    message: string;
    stack?: string;
  };
}

// 使用示例
logger.info('User action completed', {
  context: {
    userId: 'user123',
    action: 'document_import',
    module: 'library'
  },
  metadata: {
    documentCount: 5,
    fileSize: 1024000
  }
});
```

---

## 2. 性能监控

### 2.1 性能指标

#### 关键性能指标（KPI）

```typescript
// src/main/services/PerformanceMonitor.ts
export class PerformanceMonitor {
  private metrics: Map<string, PerformanceMetric[]> = new Map();
  private static readonly MAX_METRICS = 1000;

  // 记录性能指标
  public recordMetric(name: string, value: number, unit: string = 'ms') {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }

    const metrics = this.metrics.get(name)!;
    metrics.push({
      timestamp: Date.now(),
      value,
      unit
    });

    // 限制存储数量
    if (metrics.length > PerformanceMonitor.MAX_METRICS) {
      metrics.shift();
    }
  }

  // 测量函数执行时间
  public async measureAsync<T>(
    name: string,
    fn: () => Promise<T>
  ): Promise<T> {
    const startTime = performance.now();
    
    try {
      const result = await fn();
      const duration = performance.now() - startTime;
      
      this.recordMetric(name, duration);
      
      if (duration > 1000) {
        logger.warn(`Slow operation detected: ${name} took ${duration}ms`);
      }
      
      return result;
    } catch (error) {
      const duration = performance.now() - startTime;
      this.recordMetric(`${name}_error`, duration);
      throw error;
    }
  }

  // 获取性能统计
  public getStats(name: string): PerformanceStats | null {
    const metrics = this.metrics.get(name);
    if (!metrics || metrics.length === 0) return null;

    const values = metrics.map(m => m.value);
    const sorted = [...values].sort((a, b) => a - b);

    return {
      name,
      count: values.length,
      min: Math.min(...values),
      max: Math.max(...values),
      avg: values.reduce((a, b) => a + b, 0) / values.length,
      p50: this.percentile(sorted, 0.5),
      p95: this.percentile(sorted, 0.95),
      p99: this.percentile(sorted, 0.99)
    };
  }

  private percentile(sorted: number[], p: number): number {
    const index = Math.ceil(sorted.length * p) - 1;
    return sorted[Math.max(0, index)];
  }

  // 导出性能报告
  public generateReport(): PerformanceReport {
    const report: PerformanceReport = {
      timestamp: Date.now(),
      metrics: {}
    };

    for (const [name, _] of this.metrics) {
      const stats = this.getStats(name);
      if (stats) {
        report.metrics[name] = stats;
      }
    }

    return report;
  }
}

interface PerformanceMetric {
  timestamp: number;
  value: number;
  unit: string;
}

interface PerformanceStats {
  name: string;
  count: number;
  min: number;
  max: number;
  avg: number;
  p50: number;
  p95: number;
  p99: number;
}

interface PerformanceReport {
  timestamp: number;
  metrics: Record<string, PerformanceStats>;
}
```

#### 使用示例

```typescript
// 测量启动时间
await performanceMonitor.measureAsync('app_startup', async () => {
  await initializeDatabase();
  await loadUserSettings();
  await createWindow();
});

// 测量API调用
await performanceMonitor.measureAsync('ai_chat_completion', async () => {
  return await chatCompletion(options);
});

// 测量数据库查询
await performanceMonitor.measureAsync('db_query_documents', async () => {
  return await db.listDocuments();
});
```

### 2.2 内存监控

```typescript
// src/main/services/MemoryMonitor.ts
export class MemoryMonitor {
  private readonly CHECK_INTERVAL = 60000; // 1分钟
  private readonly WARNING_THRESHOLD = 500 * 1024 * 1024; // 500MB
  private readonly CRITICAL_THRESHOLD = 800 * 1024 * 1024; // 800MB

  constructor() {
    this.startMonitoring();
  }

  private startMonitoring() {
    setInterval(() => {
      this.checkMemoryUsage();
    }, this.CHECK_INTERVAL);
  }

  private checkMemoryUsage() {
    const usage = process.memoryUsage();
    
    logger.debug('Memory usage', {
      rss: this.formatBytes(usage.rss),
      heapTotal: this.formatBytes(usage.heapTotal),
      heapUsed: this.formatBytes(usage.heapUsed),
      external: this.formatBytes(usage.external)
    });

    // 检查是否超过阈值
    if (usage.heapUsed > this.CRITICAL_THRESHOLD) {
      logger.error('Critical memory usage detected', {
        heapUsed: this.formatBytes(usage.heapUsed)
      });
      
      // 尝试垃圾回收
      if (global.gc) {
        global.gc();
        logger.info('Forced garbage collection');
      }
    } else if (usage.heapUsed > this.WARNING_THRESHOLD) {
      logger.warn('High memory usage detected', {
        heapUsed: this.formatBytes(usage.heapUsed)
      });
    }
  }

  private formatBytes(bytes: number): string {
    return `${(bytes / 1024 / 1024).toFixed(2)} MB`;
  }

  public getMemoryInfo() {
    const usage = process.memoryUsage();
    return {
      rss: usage.rss,
      heapTotal: usage.heapTotal,
      heapUsed: usage.heapUsed,
      external: usage.external,
      formatted: {
        rss: this.formatBytes(usage.rss),
        heapTotal: this.formatBytes(usage.heapTotal),
        heapUsed: this.formatBytes(usage.heapUsed),
        external: this.formatBytes(usage.external)
      }
    };
  }
}
```

---

## 3. 错误监控

### 3.1 错误收集

#### 错误报告系统

```typescript
// src/main/services/ErrorReporter.ts
export class ErrorReporter {
  private errorQueue: ErrorReport[] = [];
  private readonly MAX_QUEUE_SIZE = 100;
  private readonly FLUSH_INTERVAL = 60000; // 1分钟

  constructor() {
    this.startPeriodicFlush();
  }

  // 捕获错误
  public captureError(error: Error, context?: ErrorContext) {
    const report: ErrorReport = {
      timestamp: Date.now(),
      error: {
        name: error.name,
        message: error.message,
        stack: error.stack
      },
      context: {
        platform: process.platform,
        arch: process.arch,
        appVersion: app.getVersion(),
        electronVersion: process.versions.electron,
        nodeVersion: process.versions.node,
        ...context
      },
      systemInfo: this.getSystemInfo()
    };

    this.errorQueue.push(report);

    // 立即记录到日志
    logger.error('Error captured', {
      name: error.name,
      message: error.message,
      stack: error.stack,
      context
    });

    // 如果队列太大，立即刷新
    if (this.errorQueue.length >= this.MAX_QUEUE_SIZE) {
      this.flushErrors();
    }
  }

  private getSystemInfo() {
    return {
      platform: process.platform,
      arch: process.arch,
      cpus: require('os').cpus().length,
      totalMemory: require('os').totalmem(),
      freeMemory: require('os').freemem()
    };
  }

  private startPeriodicFlush() {
    setInterval(() => {
      if (this.errorQueue.length > 0) {
        this.flushErrors();
      }
    }, this.FLUSH_INTERVAL);
  }

  private flushErrors() {
    if (this.errorQueue.length === 0) return;

    const errors = [...this.errorQueue];
    this.errorQueue = [];

    // 保存到本地文件
    this.saveErrorsToFile(errors);

    // 可选：发送到错误监控服务
    // this.sendToMonitoringService(errors);
  }

  private saveErrorsToFile(errors: ErrorReport[]) {
    const fs = require('fs');
    const path = require('path');
    
    const errorLogPath = path.join(
      app.getPath('userData'),
      'logs',
      'errors',
      `errors-${new Date().toISOString().split('T')[0]}.json`
    );

    // 确保目录存在
    fs.mkdirSync(path.dirname(errorLogPath), { recursive: true });

    // 追加到文件
    const existingErrors = fs.existsSync(errorLogPath)
      ? JSON.parse(fs.readFileSync(errorLogPath, 'utf-8'))
      : [];

    fs.writeFileSync(
      errorLogPath,
      JSON.stringify([...existingErrors, ...errors], null, 2)
    );

    logger.info(`Saved ${errors.length} errors to file`);
  }
}

interface ErrorReport {
  timestamp: number;
  error: {
    name: string;
    message: string;
    stack?: string;
  };
  context: ErrorContext;
  systemInfo: any;
}

interface ErrorContext {
  platform?: string;
  arch?: string;
  appVersion?: string;
  electronVersion?: string;
  nodeVersion?: string;
  userId?: string;
  action?: string;
  module?: string;
  [key: string]: any;
}
```

### 3.2 错误分类

#### 错误类型

```typescript
// src/types/errors.ts
export enum ErrorCategory {
  NETWORK = 'network',
  DATABASE = 'database',
  FILE_SYSTEM = 'file_system',
  AI_SERVICE = 'ai_service',
  IPC = 'ipc',
  UI = 'ui',
  UNKNOWN = 'unknown'
}

export class AppError extends Error {
  constructor(
    message: string,
    public category: ErrorCategory,
    public code?: string,
    public recoverable: boolean = true
  ) {
    super(message);
    this.name = 'AppError';
  }
}

// 具体错误类
export class NetworkError extends AppError {
  constructor(message: string, code?: string) {
    super(message, ErrorCategory.NETWORK, code);
    this.name = 'NetworkError';
  }
}

export class DatabaseError extends AppError {
  constructor(message: string, code?: string) {
    super(message, ErrorCategory.DATABASE, code, false);
    this.name = 'DatabaseError';
  }
}

export class AIServiceError extends AppError {
  constructor(message: string, code?: string) {
    super(message, ErrorCategory.AI_SERVICE, code);
    this.name = 'AIServiceError';
  }
}
```

---

## 4. 数据分析

### 4.1 使用统计

#### 用户行为追踪

```typescript
// src/main/services/AnalyticsService.ts
export class AnalyticsService {
  private events: AnalyticsEvent[] = [];
  private sessionId: string;
  private sessionStart: number;

  constructor() {
    this.sessionId = this.generateSessionId();
    this.sessionStart = Date.now();
    this.trackEvent('session_start');
  }

  // 追踪事件
  public trackEvent(
    eventName: string,
    properties?: Record<string, any>
  ) {
    const event: AnalyticsEvent = {
      sessionId: this.sessionId,
      timestamp: Date.now(),
      eventName,
      properties: {
        ...properties,
        platform: process.platform,
        appVersion: app.getVersion()
      }
    };

    this.events.push(event);
    
    logger.info('Analytics event', {
      event: eventName,
      properties
    });

    // 持久化存储
    this.persistEvents();
  }

  // 追踪页面访问
  public trackPageView(pageName: string) {
    this.trackEvent('page_view', { pageName });
  }

  // 追踪功能使用
  public trackFeatureUsage(featureName: string, metadata?: any) {
    this.trackEvent('feature_usage', {
      featureName,
      ...metadata
    });
  }

  // 追踪性能
  public trackPerformance(
    metricName: string,
    value: number,
    unit: string = 'ms'
  ) {
    this.trackEvent('performance_metric', {
      metricName,
      value,
      unit
    });
  }

  private generateSessionId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  private persistEvents() {
    // 批量保存事件到数据库
    if (this.events.length >= 10) {
      const eventsToSave = [...this.events];
      this.events = [];
      
      // 保存到SQLite
      this.saveEventsToDatabase(eventsToSave);
    }
  }

  private async saveEventsToDatabase(events: AnalyticsEvent[]) {
    // 实现数据库保存逻辑
    logger.debug(`Saved ${events.length} analytics events to database`);
  }

  // 获取统计数据
  public async getStats(timeRange?: TimeRange): Promise<UsageStats> {
    // 从数据库查询统计数据
    return {
      totalEvents: 0,
      uniqueSessions: 0,
      avgSessionDuration: 0,
      topFeatures: [],
      pageViews: {}
    };
  }
}

interface AnalyticsEvent {
  sessionId: string;
  timestamp: number;
  eventName: string;
  properties?: Record<string, any>;
}

interface UsageStats {
  totalEvents: number;
  uniqueSessions: number;
  avgSessionDuration: number;
  topFeatures: Array<{ name: string; count: number }>;
  pageViews: Record<string, number>;
}
```

### 4.2 数据可视化

#### 统计数据导出

```typescript
// src/main/services/ReportService.ts
export class ReportService {
  // 生成使用报告
  public async generateUsageReport(
    startDate: Date,
    endDate: Date
  ): Promise<UsageReport> {
    const analyticsService = new AnalyticsService();
    const performanceMonitor = new PerformanceMonitor();

    const report: UsageReport = {
      period: {
        start: startDate.toISOString(),
        end: endDate.toISOString()
      },
      usage: await analyticsService.getStats({
        start: startDate,
        end: endDate
      }),
      performance: performanceMonitor.generateReport(),
      errors: await this.getErrorStats(startDate, endDate)
    };

    return report;
  }

  private async getErrorStats(
    startDate: Date,
    endDate: Date
  ): Promise<ErrorStats> {
    // 从错误日志中统计
    return {
      totalErrors: 0,
      errorsByCategory: {},
      topErrors: []
    };
  }

  // 导出报告为JSON
  public async exportReportToJSON(
    report: UsageReport,
    filePath: string
  ) {
    const fs = require('fs');
    fs.writeFileSync(filePath, JSON.stringify(report, null, 2));
    logger.info(`Report exported to ${filePath}`);
  }

  // 导出报告为CSV
  public async exportReportToCSV(
    report: UsageReport,
    filePath: string
  ) {
    // 实现CSV导出逻辑
    logger.info(`Report exported to ${filePath}`);
  }
}

interface UsageReport {
  period: {
    start: string;
    end: string;
  };
  usage: UsageStats;
  performance: PerformanceReport;
  errors: ErrorStats;
}

interface ErrorStats {
  totalErrors: number;
  errorsByCategory: Record<string, number>;
  topErrors: Array<{ message: string; count: number }>;
}
```

---

## 5. 告警机制

### 5.1 告警规则

```typescript
// src/main/services/AlertService.ts
export class AlertService {
  private rules: AlertRule[] = [];
  private alerts: Alert[] = [];

  constructor() {
    this.initializeRules();
  }

  private initializeRules() {
    // 性能告警
    this.addRule({
      name: 'slow_startup',
      condition: (metric) => 
        metric.name === 'app_startup' && metric.value > 5000,
      severity: 'warning',
      message: '应用启动时间过长'
    });

    // 内存告警
    this.addRule({
      name: 'high_memory',
      condition: (metric) => 
        metric.name === 'memory_usage' && metric.value > 800 * 1024 * 1024,
      severity: 'critical',
      message: '内存使用过高'
    });

    // 错误告警
    this.addRule({
      name: 'high_error_rate',
      condition: (metric) => 
        metric.name === 'error_rate' && metric.value > 0.05,
      severity: 'error',
      message: '错误率过高'
    });
  }

  public addRule(rule: AlertRule) {
    this.rules.push(rule);
  }

  public checkMetric(metric: any) {
    for (const rule of this.rules) {
      if (rule.condition(metric)) {
        this.triggerAlert({
          rule: rule.name,
          severity: rule.severity,
          message: rule.message,
          timestamp: Date.now(),
          metric
        });
      }
    }
  }

  private triggerAlert(alert: Alert) {
    this.alerts.push(alert);
    
    logger.warn('Alert triggered', alert);
    
    // 发送通知
    this.sendNotification(alert);
    
    // 可选：发送到监控平台
    // this.sendToMonitoringPlatform(alert);
  }

  private sendNotification(alert: Alert) {
    const { Notification } = require('electron');
    
    if (Notification.isSupported()) {
      new Notification({
        title: `告警: ${alert.message}`,
        body: `严重程度: ${alert.severity}`,
        urgency: alert.severity === 'critical' ? 'critical' : 'normal'
      }).show();
    }
  }
}

interface AlertRule {
  name: string;
  condition: (metric: any) => boolean;
  severity: 'info' | 'warning' | 'error' | 'critical';
  message: string;
}

interface Alert {
  rule: string;
  severity: string;
  message: string;
  timestamp: number;
  metric: any;
}
```

---

## 6. 可观测性

### 6.1 健康检查

```typescript
// src/main/services/HealthCheckService.ts
export class HealthCheckService {
  private checks: HealthCheck[] = [];

  constructor() {
    this.registerChecks();
  }

  private registerChecks() {
    // 数据库健康检查
    this.registerCheck({
      name: 'database',
      check: async () => {
        try {
          await db.query('SELECT 1');
          return { healthy: true };
        } catch (error) {
          return {
            healthy: false,
            error: (error as Error).message
          };
        }
      }
    });

    // 文件系统健康检查
    this.registerCheck({
      name: 'filesystem',
      check: async () => {
        const fs = require('fs');
        const testPath = app.getPath('userData');
        
        try {
          fs.accessSync(testPath, fs.constants.W_OK);
          return { healthy: true };
        } catch (error) {
          return {
            healthy: false,
            error: '文件系统不可写'
          };
        }
      }
    });

    // 内存健康检查
    this.registerCheck({
      name: 'memory',
      check: async () => {
        const usage = process.memoryUsage();
        const threshold = 800 * 1024 * 1024; // 800MB
        
        return {
          healthy: usage.heapUsed < threshold,
          details: {
            heapUsed: usage.heapUsed,
            heapTotal: usage.heapTotal,
            threshold
          }
        };
      }
    });
  }

  public registerCheck(check: HealthCheck) {
    this.checks.push(check);
  }

  public async runHealthChecks(): Promise<HealthCheckResult> {
    const results: Record<string, any> = {};
    let overallHealthy = true;

    for (const check of this.checks) {
      try {
        const result = await check.check();
        results[check.name] = result;
        
        if (!result.healthy) {
          overallHealthy = false;
        }
      } catch (error) {
        results[check.name] = {
          healthy: false,
          error: (error as Error).message
        };
        overallHealthy = false;
      }
    }

    return {
      healthy: overallHealthy,
      timestamp: Date.now(),
      checks: results
    };
  }
}

interface HealthCheck {
  name: string;
  check: () => Promise<{
    healthy: boolean;
    error?: string;
    details?: any;
  }>;
}

interface HealthCheckResult {
  healthy: boolean;
  timestamp: number;
  checks: Record<string, any>;
}
```

### 6.2 诊断工具

```typescript
// src/main/services/DiagnosticsService.ts
export class DiagnosticsService {
  // 生成诊断报告
  public async generateDiagnosticReport(): Promise<DiagnosticReport> {
    const healthCheck = new HealthCheckService();
    const performanceMonitor = new PerformanceMonitor();
    const memoryMonitor = new MemoryMonitor();

    return {
      timestamp: Date.now(),
      appVersion: app.getVersion(),
      platform: process.platform,
      arch: process.arch,
      health: await healthCheck.runHealthChecks(),
      performance: performanceMonitor.generateReport(),
      memory: memoryMonitor.getMemoryInfo(),
      logs: this.getRecentLogs(),
      errors: this.getRecentErrors()
    };
  }

  private getRecentLogs(): string[] {
    // 获取最近的日志条目
    return [];
  }

  private getRecentErrors(): ErrorReport[] {
    // 获取最近的错误
    return [];
  }

  // 导出诊断报告
  public async exportDiagnosticReport(filePath: string) {
    const report = await this.generateDiagnosticReport();
    const fs = require('fs');
    
    fs.writeFileSync(filePath, JSON.stringify(report, null, 2));
    logger.info(`Diagnostic report exported to ${filePath}`);
  }
}

interface DiagnosticReport {
  timestamp: number;
  appVersion: string;
  platform: string;
  arch: string;
  health: HealthCheckResult;
  performance: PerformanceReport;
  memory: any;
  logs: string[];
  errors: ErrorReport[];
}
```

---

## 📝 总结

### 🎯 日志监控核心

1. **完整的日志系统**: 多级别日志、结构化日志、日志轮转
2. **性能监控**: 关键指标追踪、性能分析、性能告警
3. **错误监控**: 错误捕获、错误分类、错误报告
4. **数据分析**: 使用统计、行为追踪、数据可视化
5. **告警机制**: 规则配置、实时告警、通知推送
6. **可观测性**: 健康检查、诊断工具、系统状态

### 📈 最佳实践

- **结构化日志**: 使用统一的日志格式
- **异步处理**: 避免日志影响应用性能
- **日志轮转**: 定期清理旧日志文件
- **隐私保护**: 不记录敏感信息
- **监控覆盖**: 覆盖关键路径和关键指标

### 🎖️ 监控价值

- 快速定位和解决问题
- 了解应用使用情况
- 优化性能和用户体验
- 提前发现潜在问题
- 数据驱动的决策支持

通过完善的日志监控体系，确保应用的稳定性、可靠性和可维护性。

---

*本文档将随着项目发展持续更新和完善。*
*最后更新: 2025-10-19*

