# è¶£çŸ¥æ¡Œé¢ç‰ˆ - æ—¥å¿—ç›‘æ§

<div align="center">
  <h1>ğŸ“Š è¶£çŸ¥æ¡Œé¢ç‰ˆæ—¥å¿—ç›‘æ§</h1>
  <p>å®Œæ•´çš„æ—¥å¿—ç³»ç»Ÿä¸åº”ç”¨ç›‘æ§æ–¹æ¡ˆ</p>
</div>

---

## ğŸ“– ç›®å½•

1. [æ—¥å¿—ç³»ç»Ÿ](#1-æ—¥å¿—ç³»ç»Ÿ)
2. [æ€§èƒ½ç›‘æ§](#2-æ€§èƒ½ç›‘æ§)
3. [é”™è¯¯ç›‘æ§](#3-é”™è¯¯ç›‘æ§)
4. [æ•°æ®åˆ†æ](#4-æ•°æ®åˆ†æ)
5. [å‘Šè­¦æœºåˆ¶](#5-å‘Šè­¦æœºåˆ¶)
6. [å¯è§‚æµ‹æ€§](#6-å¯è§‚æµ‹æ€§)

---

## 1. æ—¥å¿—ç³»ç»Ÿ

### 1.1 æ—¥å¿—çº§åˆ«

#### æ—¥å¿—çº§åˆ«å®šä¹‰

| çº§åˆ« | ç”¨é€” | ç¤ºä¾‹ |
|------|------|------|
| **error** | é”™è¯¯ä¿¡æ¯ï¼Œéœ€è¦ç«‹å³å…³æ³¨ | APIè°ƒç”¨å¤±è´¥ã€æ•°æ®åº“é”™è¯¯ |
| **warn** | è­¦å‘Šä¿¡æ¯ï¼Œå¯èƒ½å½±å“åŠŸèƒ½ | é…ç½®ç¼ºå¤±ã€æ€§èƒ½é™çº§ |
| **info** | é‡è¦ä¿¡æ¯ï¼Œå…³é”®æ“ä½œè®°å½• | ç”¨æˆ·ç™»å½•ã€æ•°æ®å¯¼å…¥ |
| **debug** | è°ƒè¯•ä¿¡æ¯ï¼Œå¼€å‘ç¯å¢ƒä½¿ç”¨ | å‡½æ•°è°ƒç”¨ã€å˜é‡å€¼ |
| **verbose** | è¯¦ç»†ä¿¡æ¯ï¼Œå®Œæ•´æµç¨‹è®°å½• | è¯¦ç»†çš„è¯·æ±‚å“åº” |

### 1.2 æ—¥å¿—é…ç½®

#### electron-logé…ç½®

```typescript
// src/main/services/LoggerService.ts
import log from 'electron-log';
import { app } from 'electron';
import path from 'path';

export class LoggerService {
  private static instance: LoggerService;

  private constructor() {
    this.setupLogger();
  }

  public static getInstance(): LoggerService {
    if (!LoggerService.instance) {
      LoggerService.instance = new LoggerService();
    }
    return LoggerService.instance;
  }

  private setupLogger() {
    // æ—¥å¿—æ–‡ä»¶è·¯å¾„
    const logPath = path.join(app.getPath('userData'), 'logs');
    
    // ä¸»è¿›ç¨‹æ—¥å¿—é…ç½®
    log.transports.file.level = 'info';
    log.transports.file.maxSize = 10 * 1024 * 1024; // 10MB
    log.transports.file.format = '{y}-{m}-{d} {h}:{i}:{s}.{ms} [{level}] {text}';
    log.transports.file.resolvePath = (variables) => {
      return path.join(logPath, `main-${variables.fileName}`);
    };

    // æ§åˆ¶å°è¾“å‡ºé…ç½®
    log.transports.console.level = process.env.NODE_ENV === 'development' ? 'debug' : 'warn';
    log.transports.console.format = '{h}:{i}:{s} [{level}] {text}';

    // æ—¥å¿—è½®è½¬
    log.transports.file.archiveLog = (oldLogFile) => {
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const archivePath = path.join(logPath, 'archive', `${timestamp}.log`);
      
      require('fs').renameSync(oldLogFile.path, archivePath);
    };

    // æ•è·æœªå¤„ç†çš„å¼‚å¸¸
    this.setupErrorHandlers();
  }

  private setupErrorHandlers() {
    // æœªæ•è·çš„å¼‚å¸¸
    process.on('uncaughtException', (error) => {
      log.error('Uncaught Exception:', error);
      // ä¸é€€å‡ºè¿›ç¨‹ï¼Œè®°å½•é”™è¯¯ç»§ç»­è¿è¡Œ
    });

    // æœªå¤„ç†çš„Promiseæ‹’ç»
    process.on('unhandledRejection', (reason, promise) => {
      log.error('Unhandled Rejection at:', promise, 'reason:', reason);
    });
  }

  // æ—¥å¿—æ–¹æ³•å°è£…
  public error(message: string, ...args: any[]) {
    log.error(this.formatMessage(message), ...args);
  }

  public warn(message: string, ...args: any[]) {
    log.warn(this.formatMessage(message), ...args);
  }

  public info(message: string, ...args: any[]) {
    log.info(this.formatMessage(message), ...args);
  }

  public debug(message: string, ...args: any[]) {
    log.debug(this.formatMessage(message), ...args);
  }

  public verbose(message: string, ...args: any[]) {
    log.verbose(this.formatMessage(message), ...args);
  }

  private formatMessage(message: string): string {
    const stack = new Error().stack;
    const caller = stack?.split('\n')[3]?.trim() || '';
    return `[${caller}] ${message}`;
  }

  // è·å–æ—¥å¿—æ–‡ä»¶è·¯å¾„
  public getLogPath(): string {
    return log.transports.file.getFile().path;
  }

  // æ¸…ç†æ—§æ—¥å¿—
  public cleanOldLogs(daysToKeep: number = 7) {
    const logPath = path.join(app.getPath('userData'), 'logs');
    const fs = require('fs');
    const files = fs.readdirSync(logPath);
    
    const cutoffDate = Date.now() - daysToKeep * 24 * 60 * 60 * 1000;
    
    files.forEach((file: string) => {
      const filePath = path.join(logPath, file);
      const stats = fs.statSync(filePath);
      
      if (stats.mtime.getTime() < cutoffDate) {
        fs.unlinkSync(filePath);
        log.info(`Deleted old log file: ${file}`);
      }
    });
  }
}
```

#### æ¸²æŸ“è¿›ç¨‹æ—¥å¿—

```typescript
// src/renderer/services/RendererLogger.ts
export class RendererLogger {
  private static sendToMain(level: string, message: string, ...args: any[]) {
    // é€šè¿‡IPCå‘é€æ—¥å¿—åˆ°ä¸»è¿›ç¨‹
    window.electronAPI?.log?.send(level, message, ...args);
    
    // æœ¬åœ°ä¹Ÿè¾“å‡ºåˆ°æ§åˆ¶å°
    if (process.env.NODE_ENV === 'development') {
      console[level as 'log' | 'error' | 'warn' | 'info'](message, ...args);
    }
  }

  public static error(message: string, ...args: any[]) {
    this.sendToMain('error', message, ...args);
  }

  public static warn(message: string, ...args: any[]) {
    this.sendToMain('warn', message, ...args);
  }

  public static info(message: string, ...args: any[]) {
    this.sendToMain('info', message, ...args);
  }

  public static debug(message: string, ...args: any[]) {
    this.sendToMain('debug', message, ...args);
  }
}
```

### 1.3 ç»“æ„åŒ–æ—¥å¿—

#### æ—¥å¿—æ ¼å¼

```typescript
interface LogEntry {
  timestamp: string;
  level: 'error' | 'warn' | 'info' | 'debug';
  message: string;
  context?: {
    userId?: string;
    sessionId?: string;
    action?: string;
    module?: string;
  };
  metadata?: Record<string, any>;
  error?: {
    name: string;
    message: string;
    stack?: string;
  };
}

// ä½¿ç”¨ç¤ºä¾‹
logger.info('User action completed', {
  context: {
    userId: 'user123',
    action: 'document_import',
    module: 'library'
  },
  metadata: {
    documentCount: 5,
    fileSize: 1024000
  }
});
```

---

## 2. æ€§èƒ½ç›‘æ§

### 2.1 æ€§èƒ½æŒ‡æ ‡

#### å…³é”®æ€§èƒ½æŒ‡æ ‡ï¼ˆKPIï¼‰

```typescript
// src/main/services/PerformanceMonitor.ts
export class PerformanceMonitor {
  private metrics: Map<string, PerformanceMetric[]> = new Map();
  private static readonly MAX_METRICS = 1000;

  // è®°å½•æ€§èƒ½æŒ‡æ ‡
  public recordMetric(name: string, value: number, unit: string = 'ms') {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }

    const metrics = this.metrics.get(name)!;
    metrics.push({
      timestamp: Date.now(),
      value,
      unit
    });

    // é™åˆ¶å­˜å‚¨æ•°é‡
    if (metrics.length > PerformanceMonitor.MAX_METRICS) {
      metrics.shift();
    }
  }

  // æµ‹é‡å‡½æ•°æ‰§è¡Œæ—¶é—´
  public async measureAsync<T>(
    name: string,
    fn: () => Promise<T>
  ): Promise<T> {
    const startTime = performance.now();
    
    try {
      const result = await fn();
      const duration = performance.now() - startTime;
      
      this.recordMetric(name, duration);
      
      if (duration > 1000) {
        logger.warn(`Slow operation detected: ${name} took ${duration}ms`);
      }
      
      return result;
    } catch (error) {
      const duration = performance.now() - startTime;
      this.recordMetric(`${name}_error`, duration);
      throw error;
    }
  }

  // è·å–æ€§èƒ½ç»Ÿè®¡
  public getStats(name: string): PerformanceStats | null {
    const metrics = this.metrics.get(name);
    if (!metrics || metrics.length === 0) return null;

    const values = metrics.map(m => m.value);
    const sorted = [...values].sort((a, b) => a - b);

    return {
      name,
      count: values.length,
      min: Math.min(...values),
      max: Math.max(...values),
      avg: values.reduce((a, b) => a + b, 0) / values.length,
      p50: this.percentile(sorted, 0.5),
      p95: this.percentile(sorted, 0.95),
      p99: this.percentile(sorted, 0.99)
    };
  }

  private percentile(sorted: number[], p: number): number {
    const index = Math.ceil(sorted.length * p) - 1;
    return sorted[Math.max(0, index)];
  }

  // å¯¼å‡ºæ€§èƒ½æŠ¥å‘Š
  public generateReport(): PerformanceReport {
    const report: PerformanceReport = {
      timestamp: Date.now(),
      metrics: {}
    };

    for (const [name, _] of this.metrics) {
      const stats = this.getStats(name);
      if (stats) {
        report.metrics[name] = stats;
      }
    }

    return report;
  }
}

interface PerformanceMetric {
  timestamp: number;
  value: number;
  unit: string;
}

interface PerformanceStats {
  name: string;
  count: number;
  min: number;
  max: number;
  avg: number;
  p50: number;
  p95: number;
  p99: number;
}

interface PerformanceReport {
  timestamp: number;
  metrics: Record<string, PerformanceStats>;
}
```

#### ä½¿ç”¨ç¤ºä¾‹

```typescript
// æµ‹é‡å¯åŠ¨æ—¶é—´
await performanceMonitor.measureAsync('app_startup', async () => {
  await initializeDatabase();
  await loadUserSettings();
  await createWindow();
});

// æµ‹é‡APIè°ƒç”¨
await performanceMonitor.measureAsync('ai_chat_completion', async () => {
  return await chatCompletion(options);
});

// æµ‹é‡æ•°æ®åº“æŸ¥è¯¢
await performanceMonitor.measureAsync('db_query_documents', async () => {
  return await db.listDocuments();
});
```

### 2.2 å†…å­˜ç›‘æ§

```typescript
// src/main/services/MemoryMonitor.ts
export class MemoryMonitor {
  private readonly CHECK_INTERVAL = 60000; // 1åˆ†é’Ÿ
  private readonly WARNING_THRESHOLD = 500 * 1024 * 1024; // 500MB
  private readonly CRITICAL_THRESHOLD = 800 * 1024 * 1024; // 800MB

  constructor() {
    this.startMonitoring();
  }

  private startMonitoring() {
    setInterval(() => {
      this.checkMemoryUsage();
    }, this.CHECK_INTERVAL);
  }

  private checkMemoryUsage() {
    const usage = process.memoryUsage();
    
    logger.debug('Memory usage', {
      rss: this.formatBytes(usage.rss),
      heapTotal: this.formatBytes(usage.heapTotal),
      heapUsed: this.formatBytes(usage.heapUsed),
      external: this.formatBytes(usage.external)
    });

    // æ£€æŸ¥æ˜¯å¦è¶…è¿‡é˜ˆå€¼
    if (usage.heapUsed > this.CRITICAL_THRESHOLD) {
      logger.error('Critical memory usage detected', {
        heapUsed: this.formatBytes(usage.heapUsed)
      });
      
      // å°è¯•åƒåœ¾å›æ”¶
      if (global.gc) {
        global.gc();
        logger.info('Forced garbage collection');
      }
    } else if (usage.heapUsed > this.WARNING_THRESHOLD) {
      logger.warn('High memory usage detected', {
        heapUsed: this.formatBytes(usage.heapUsed)
      });
    }
  }

  private formatBytes(bytes: number): string {
    return `${(bytes / 1024 / 1024).toFixed(2)} MB`;
  }

  public getMemoryInfo() {
    const usage = process.memoryUsage();
    return {
      rss: usage.rss,
      heapTotal: usage.heapTotal,
      heapUsed: usage.heapUsed,
      external: usage.external,
      formatted: {
        rss: this.formatBytes(usage.rss),
        heapTotal: this.formatBytes(usage.heapTotal),
        heapUsed: this.formatBytes(usage.heapUsed),
        external: this.formatBytes(usage.external)
      }
    };
  }
}
```

---

## 3. é”™è¯¯ç›‘æ§

### 3.1 é”™è¯¯æ”¶é›†

#### é”™è¯¯æŠ¥å‘Šç³»ç»Ÿ

```typescript
// src/main/services/ErrorReporter.ts
export class ErrorReporter {
  private errorQueue: ErrorReport[] = [];
  private readonly MAX_QUEUE_SIZE = 100;
  private readonly FLUSH_INTERVAL = 60000; // 1åˆ†é’Ÿ

  constructor() {
    this.startPeriodicFlush();
  }

  // æ•è·é”™è¯¯
  public captureError(error: Error, context?: ErrorContext) {
    const report: ErrorReport = {
      timestamp: Date.now(),
      error: {
        name: error.name,
        message: error.message,
        stack: error.stack
      },
      context: {
        platform: process.platform,
        arch: process.arch,
        appVersion: app.getVersion(),
        electronVersion: process.versions.electron,
        nodeVersion: process.versions.node,
        ...context
      },
      systemInfo: this.getSystemInfo()
    };

    this.errorQueue.push(report);

    // ç«‹å³è®°å½•åˆ°æ—¥å¿—
    logger.error('Error captured', {
      name: error.name,
      message: error.message,
      stack: error.stack,
      context
    });

    // å¦‚æœé˜Ÿåˆ—å¤ªå¤§ï¼Œç«‹å³åˆ·æ–°
    if (this.errorQueue.length >= this.MAX_QUEUE_SIZE) {
      this.flushErrors();
    }
  }

  private getSystemInfo() {
    return {
      platform: process.platform,
      arch: process.arch,
      cpus: require('os').cpus().length,
      totalMemory: require('os').totalmem(),
      freeMemory: require('os').freemem()
    };
  }

  private startPeriodicFlush() {
    setInterval(() => {
      if (this.errorQueue.length > 0) {
        this.flushErrors();
      }
    }, this.FLUSH_INTERVAL);
  }

  private flushErrors() {
    if (this.errorQueue.length === 0) return;

    const errors = [...this.errorQueue];
    this.errorQueue = [];

    // ä¿å­˜åˆ°æœ¬åœ°æ–‡ä»¶
    this.saveErrorsToFile(errors);

    // å¯é€‰ï¼šå‘é€åˆ°é”™è¯¯ç›‘æ§æœåŠ¡
    // this.sendToMonitoringService(errors);
  }

  private saveErrorsToFile(errors: ErrorReport[]) {
    const fs = require('fs');
    const path = require('path');
    
    const errorLogPath = path.join(
      app.getPath('userData'),
      'logs',
      'errors',
      `errors-${new Date().toISOString().split('T')[0]}.json`
    );

    // ç¡®ä¿ç›®å½•å­˜åœ¨
    fs.mkdirSync(path.dirname(errorLogPath), { recursive: true });

    // è¿½åŠ åˆ°æ–‡ä»¶
    const existingErrors = fs.existsSync(errorLogPath)
      ? JSON.parse(fs.readFileSync(errorLogPath, 'utf-8'))
      : [];

    fs.writeFileSync(
      errorLogPath,
      JSON.stringify([...existingErrors, ...errors], null, 2)
    );

    logger.info(`Saved ${errors.length} errors to file`);
  }
}

interface ErrorReport {
  timestamp: number;
  error: {
    name: string;
    message: string;
    stack?: string;
  };
  context: ErrorContext;
  systemInfo: any;
}

interface ErrorContext {
  platform?: string;
  arch?: string;
  appVersion?: string;
  electronVersion?: string;
  nodeVersion?: string;
  userId?: string;
  action?: string;
  module?: string;
  [key: string]: any;
}
```

### 3.2 é”™è¯¯åˆ†ç±»

#### é”™è¯¯ç±»å‹

```typescript
// src/types/errors.ts
export enum ErrorCategory {
  NETWORK = 'network',
  DATABASE = 'database',
  FILE_SYSTEM = 'file_system',
  AI_SERVICE = 'ai_service',
  IPC = 'ipc',
  UI = 'ui',
  UNKNOWN = 'unknown'
}

export class AppError extends Error {
  constructor(
    message: string,
    public category: ErrorCategory,
    public code?: string,
    public recoverable: boolean = true
  ) {
    super(message);
    this.name = 'AppError';
  }
}

// å…·ä½“é”™è¯¯ç±»
export class NetworkError extends AppError {
  constructor(message: string, code?: string) {
    super(message, ErrorCategory.NETWORK, code);
    this.name = 'NetworkError';
  }
}

export class DatabaseError extends AppError {
  constructor(message: string, code?: string) {
    super(message, ErrorCategory.DATABASE, code, false);
    this.name = 'DatabaseError';
  }
}

export class AIServiceError extends AppError {
  constructor(message: string, code?: string) {
    super(message, ErrorCategory.AI_SERVICE, code);
    this.name = 'AIServiceError';
  }
}
```

---

## 4. æ•°æ®åˆ†æ

### 4.1 ä½¿ç”¨ç»Ÿè®¡

#### ç”¨æˆ·è¡Œä¸ºè¿½è¸ª

```typescript
// src/main/services/AnalyticsService.ts
export class AnalyticsService {
  private events: AnalyticsEvent[] = [];
  private sessionId: string;
  private sessionStart: number;

  constructor() {
    this.sessionId = this.generateSessionId();
    this.sessionStart = Date.now();
    this.trackEvent('session_start');
  }

  // è¿½è¸ªäº‹ä»¶
  public trackEvent(
    eventName: string,
    properties?: Record<string, any>
  ) {
    const event: AnalyticsEvent = {
      sessionId: this.sessionId,
      timestamp: Date.now(),
      eventName,
      properties: {
        ...properties,
        platform: process.platform,
        appVersion: app.getVersion()
      }
    };

    this.events.push(event);
    
    logger.info('Analytics event', {
      event: eventName,
      properties
    });

    // æŒä¹…åŒ–å­˜å‚¨
    this.persistEvents();
  }

  // è¿½è¸ªé¡µé¢è®¿é—®
  public trackPageView(pageName: string) {
    this.trackEvent('page_view', { pageName });
  }

  // è¿½è¸ªåŠŸèƒ½ä½¿ç”¨
  public trackFeatureUsage(featureName: string, metadata?: any) {
    this.trackEvent('feature_usage', {
      featureName,
      ...metadata
    });
  }

  // è¿½è¸ªæ€§èƒ½
  public trackPerformance(
    metricName: string,
    value: number,
    unit: string = 'ms'
  ) {
    this.trackEvent('performance_metric', {
      metricName,
      value,
      unit
    });
  }

  private generateSessionId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  private persistEvents() {
    // æ‰¹é‡ä¿å­˜äº‹ä»¶åˆ°æ•°æ®åº“
    if (this.events.length >= 10) {
      const eventsToSave = [...this.events];
      this.events = [];
      
      // ä¿å­˜åˆ°SQLite
      this.saveEventsToDatabase(eventsToSave);
    }
  }

  private async saveEventsToDatabase(events: AnalyticsEvent[]) {
    // å®ç°æ•°æ®åº“ä¿å­˜é€»è¾‘
    logger.debug(`Saved ${events.length} analytics events to database`);
  }

  // è·å–ç»Ÿè®¡æ•°æ®
  public async getStats(timeRange?: TimeRange): Promise<UsageStats> {
    // ä»æ•°æ®åº“æŸ¥è¯¢ç»Ÿè®¡æ•°æ®
    return {
      totalEvents: 0,
      uniqueSessions: 0,
      avgSessionDuration: 0,
      topFeatures: [],
      pageViews: {}
    };
  }
}

interface AnalyticsEvent {
  sessionId: string;
  timestamp: number;
  eventName: string;
  properties?: Record<string, any>;
}

interface UsageStats {
  totalEvents: number;
  uniqueSessions: number;
  avgSessionDuration: number;
  topFeatures: Array<{ name: string; count: number }>;
  pageViews: Record<string, number>;
}
```

### 4.2 æ•°æ®å¯è§†åŒ–

#### ç»Ÿè®¡æ•°æ®å¯¼å‡º

```typescript
// src/main/services/ReportService.ts
export class ReportService {
  // ç”Ÿæˆä½¿ç”¨æŠ¥å‘Š
  public async generateUsageReport(
    startDate: Date,
    endDate: Date
  ): Promise<UsageReport> {
    const analyticsService = new AnalyticsService();
    const performanceMonitor = new PerformanceMonitor();

    const report: UsageReport = {
      period: {
        start: startDate.toISOString(),
        end: endDate.toISOString()
      },
      usage: await analyticsService.getStats({
        start: startDate,
        end: endDate
      }),
      performance: performanceMonitor.generateReport(),
      errors: await this.getErrorStats(startDate, endDate)
    };

    return report;
  }

  private async getErrorStats(
    startDate: Date,
    endDate: Date
  ): Promise<ErrorStats> {
    // ä»é”™è¯¯æ—¥å¿—ä¸­ç»Ÿè®¡
    return {
      totalErrors: 0,
      errorsByCategory: {},
      topErrors: []
    };
  }

  // å¯¼å‡ºæŠ¥å‘Šä¸ºJSON
  public async exportReportToJSON(
    report: UsageReport,
    filePath: string
  ) {
    const fs = require('fs');
    fs.writeFileSync(filePath, JSON.stringify(report, null, 2));
    logger.info(`Report exported to ${filePath}`);
  }

  // å¯¼å‡ºæŠ¥å‘Šä¸ºCSV
  public async exportReportToCSV(
    report: UsageReport,
    filePath: string
  ) {
    // å®ç°CSVå¯¼å‡ºé€»è¾‘
    logger.info(`Report exported to ${filePath}`);
  }
}

interface UsageReport {
  period: {
    start: string;
    end: string;
  };
  usage: UsageStats;
  performance: PerformanceReport;
  errors: ErrorStats;
}

interface ErrorStats {
  totalErrors: number;
  errorsByCategory: Record<string, number>;
  topErrors: Array<{ message: string; count: number }>;
}
```

---

## 5. å‘Šè­¦æœºåˆ¶

### 5.1 å‘Šè­¦è§„åˆ™

```typescript
// src/main/services/AlertService.ts
export class AlertService {
  private rules: AlertRule[] = [];
  private alerts: Alert[] = [];

  constructor() {
    this.initializeRules();
  }

  private initializeRules() {
    // æ€§èƒ½å‘Šè­¦
    this.addRule({
      name: 'slow_startup',
      condition: (metric) => 
        metric.name === 'app_startup' && metric.value > 5000,
      severity: 'warning',
      message: 'åº”ç”¨å¯åŠ¨æ—¶é—´è¿‡é•¿'
    });

    // å†…å­˜å‘Šè­¦
    this.addRule({
      name: 'high_memory',
      condition: (metric) => 
        metric.name === 'memory_usage' && metric.value > 800 * 1024 * 1024,
      severity: 'critical',
      message: 'å†…å­˜ä½¿ç”¨è¿‡é«˜'
    });

    // é”™è¯¯å‘Šè­¦
    this.addRule({
      name: 'high_error_rate',
      condition: (metric) => 
        metric.name === 'error_rate' && metric.value > 0.05,
      severity: 'error',
      message: 'é”™è¯¯ç‡è¿‡é«˜'
    });
  }

  public addRule(rule: AlertRule) {
    this.rules.push(rule);
  }

  public checkMetric(metric: any) {
    for (const rule of this.rules) {
      if (rule.condition(metric)) {
        this.triggerAlert({
          rule: rule.name,
          severity: rule.severity,
          message: rule.message,
          timestamp: Date.now(),
          metric
        });
      }
    }
  }

  private triggerAlert(alert: Alert) {
    this.alerts.push(alert);
    
    logger.warn('Alert triggered', alert);
    
    // å‘é€é€šçŸ¥
    this.sendNotification(alert);
    
    // å¯é€‰ï¼šå‘é€åˆ°ç›‘æ§å¹³å°
    // this.sendToMonitoringPlatform(alert);
  }

  private sendNotification(alert: Alert) {
    const { Notification } = require('electron');
    
    if (Notification.isSupported()) {
      new Notification({
        title: `å‘Šè­¦: ${alert.message}`,
        body: `ä¸¥é‡ç¨‹åº¦: ${alert.severity}`,
        urgency: alert.severity === 'critical' ? 'critical' : 'normal'
      }).show();
    }
  }
}

interface AlertRule {
  name: string;
  condition: (metric: any) => boolean;
  severity: 'info' | 'warning' | 'error' | 'critical';
  message: string;
}

interface Alert {
  rule: string;
  severity: string;
  message: string;
  timestamp: number;
  metric: any;
}
```

---

## 6. å¯è§‚æµ‹æ€§

### 6.1 å¥åº·æ£€æŸ¥

```typescript
// src/main/services/HealthCheckService.ts
export class HealthCheckService {
  private checks: HealthCheck[] = [];

  constructor() {
    this.registerChecks();
  }

  private registerChecks() {
    // æ•°æ®åº“å¥åº·æ£€æŸ¥
    this.registerCheck({
      name: 'database',
      check: async () => {
        try {
          await db.query('SELECT 1');
          return { healthy: true };
        } catch (error) {
          return {
            healthy: false,
            error: (error as Error).message
          };
        }
      }
    });

    // æ–‡ä»¶ç³»ç»Ÿå¥åº·æ£€æŸ¥
    this.registerCheck({
      name: 'filesystem',
      check: async () => {
        const fs = require('fs');
        const testPath = app.getPath('userData');
        
        try {
          fs.accessSync(testPath, fs.constants.W_OK);
          return { healthy: true };
        } catch (error) {
          return {
            healthy: false,
            error: 'æ–‡ä»¶ç³»ç»Ÿä¸å¯å†™'
          };
        }
      }
    });

    // å†…å­˜å¥åº·æ£€æŸ¥
    this.registerCheck({
      name: 'memory',
      check: async () => {
        const usage = process.memoryUsage();
        const threshold = 800 * 1024 * 1024; // 800MB
        
        return {
          healthy: usage.heapUsed < threshold,
          details: {
            heapUsed: usage.heapUsed,
            heapTotal: usage.heapTotal,
            threshold
          }
        };
      }
    });
  }

  public registerCheck(check: HealthCheck) {
    this.checks.push(check);
  }

  public async runHealthChecks(): Promise<HealthCheckResult> {
    const results: Record<string, any> = {};
    let overallHealthy = true;

    for (const check of this.checks) {
      try {
        const result = await check.check();
        results[check.name] = result;
        
        if (!result.healthy) {
          overallHealthy = false;
        }
      } catch (error) {
        results[check.name] = {
          healthy: false,
          error: (error as Error).message
        };
        overallHealthy = false;
      }
    }

    return {
      healthy: overallHealthy,
      timestamp: Date.now(),
      checks: results
    };
  }
}

interface HealthCheck {
  name: string;
  check: () => Promise<{
    healthy: boolean;
    error?: string;
    details?: any;
  }>;
}

interface HealthCheckResult {
  healthy: boolean;
  timestamp: number;
  checks: Record<string, any>;
}
```

### 6.2 è¯Šæ–­å·¥å…·

```typescript
// src/main/services/DiagnosticsService.ts
export class DiagnosticsService {
  // ç”Ÿæˆè¯Šæ–­æŠ¥å‘Š
  public async generateDiagnosticReport(): Promise<DiagnosticReport> {
    const healthCheck = new HealthCheckService();
    const performanceMonitor = new PerformanceMonitor();
    const memoryMonitor = new MemoryMonitor();

    return {
      timestamp: Date.now(),
      appVersion: app.getVersion(),
      platform: process.platform,
      arch: process.arch,
      health: await healthCheck.runHealthChecks(),
      performance: performanceMonitor.generateReport(),
      memory: memoryMonitor.getMemoryInfo(),
      logs: this.getRecentLogs(),
      errors: this.getRecentErrors()
    };
  }

  private getRecentLogs(): string[] {
    // è·å–æœ€è¿‘çš„æ—¥å¿—æ¡ç›®
    return [];
  }

  private getRecentErrors(): ErrorReport[] {
    // è·å–æœ€è¿‘çš„é”™è¯¯
    return [];
  }

  // å¯¼å‡ºè¯Šæ–­æŠ¥å‘Š
  public async exportDiagnosticReport(filePath: string) {
    const report = await this.generateDiagnosticReport();
    const fs = require('fs');
    
    fs.writeFileSync(filePath, JSON.stringify(report, null, 2));
    logger.info(`Diagnostic report exported to ${filePath}`);
  }
}

interface DiagnosticReport {
  timestamp: number;
  appVersion: string;
  platform: string;
  arch: string;
  health: HealthCheckResult;
  performance: PerformanceReport;
  memory: any;
  logs: string[];
  errors: ErrorReport[];
}
```

---

## ğŸ“ æ€»ç»“

### ğŸ¯ æ—¥å¿—ç›‘æ§æ ¸å¿ƒ

1. **å®Œæ•´çš„æ—¥å¿—ç³»ç»Ÿ**: å¤šçº§åˆ«æ—¥å¿—ã€ç»“æ„åŒ–æ—¥å¿—ã€æ—¥å¿—è½®è½¬
2. **æ€§èƒ½ç›‘æ§**: å…³é”®æŒ‡æ ‡è¿½è¸ªã€æ€§èƒ½åˆ†æã€æ€§èƒ½å‘Šè­¦
3. **é”™è¯¯ç›‘æ§**: é”™è¯¯æ•è·ã€é”™è¯¯åˆ†ç±»ã€é”™è¯¯æŠ¥å‘Š
4. **æ•°æ®åˆ†æ**: ä½¿ç”¨ç»Ÿè®¡ã€è¡Œä¸ºè¿½è¸ªã€æ•°æ®å¯è§†åŒ–
5. **å‘Šè­¦æœºåˆ¶**: è§„åˆ™é…ç½®ã€å®æ—¶å‘Šè­¦ã€é€šçŸ¥æ¨é€
6. **å¯è§‚æµ‹æ€§**: å¥åº·æ£€æŸ¥ã€è¯Šæ–­å·¥å…·ã€ç³»ç»ŸçŠ¶æ€

### ğŸ“ˆ æœ€ä½³å®è·µ

- **ç»“æ„åŒ–æ—¥å¿—**: ä½¿ç”¨ç»Ÿä¸€çš„æ—¥å¿—æ ¼å¼
- **å¼‚æ­¥å¤„ç†**: é¿å…æ—¥å¿—å½±å“åº”ç”¨æ€§èƒ½
- **æ—¥å¿—è½®è½¬**: å®šæœŸæ¸…ç†æ—§æ—¥å¿—æ–‡ä»¶
- **éšç§ä¿æŠ¤**: ä¸è®°å½•æ•æ„Ÿä¿¡æ¯
- **ç›‘æ§è¦†ç›–**: è¦†ç›–å…³é”®è·¯å¾„å’Œå…³é”®æŒ‡æ ‡

### ğŸ–ï¸ ç›‘æ§ä»·å€¼

- å¿«é€Ÿå®šä½å’Œè§£å†³é—®é¢˜
- äº†è§£åº”ç”¨ä½¿ç”¨æƒ…å†µ
- ä¼˜åŒ–æ€§èƒ½å’Œç”¨æˆ·ä½“éªŒ
- æå‰å‘ç°æ½œåœ¨é—®é¢˜
- æ•°æ®é©±åŠ¨çš„å†³ç­–æ”¯æŒ

é€šè¿‡å®Œå–„çš„æ—¥å¿—ç›‘æ§ä½“ç³»ï¼Œç¡®ä¿åº”ç”¨çš„ç¨³å®šæ€§ã€å¯é æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚

---

*æœ¬æ–‡æ¡£å°†éšç€é¡¹ç›®å‘å±•æŒç»­æ›´æ–°å’Œå®Œå–„ã€‚*
*æœ€åæ›´æ–°: 2025-10-19*

